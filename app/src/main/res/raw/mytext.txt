1. 시험관련

해당 과목은 퀴즈,기말 문제가 생각보다 까다로웠습니다.

단순히 족보로 검색해서 시험본다고 다 맞을수 있는것이 아니라

논리적인 생각을 요구하는 문제도 여러 있었고, 

수업에서 언급했던 내용도 [ex) 공룡의 뇌에 대한 문제] 출제되니 2배속이라도 한번씩은 강의를 듣는것을 추천합니다.

그리고 인터넷 검색을 의존하지 말고 교수님께서 말씀하셨던 내용과 강의안을 무조건 따르시길바랍니다.

[ex) 기말문제중 '우리나라의 생활체육 참여율이 매년 증가하고 있다'라는 O,X문제가 출제되었는데,
 인터넷 검색결과 꾸준히 증가하고 있지는 않았지만 교수님이 증가하고 있다는 언급을 하셔서 해당문제를 O로 체크,
 교수님은 O만을 정답으로 인정하심 ]

다시한번 말하지만 인터넷검색보다는 수업에서 언급했던 내용과 교안을 무조건 따르시길 바랍니다.


2. 과제관련 (기타참여도과제 10%, 과제 30%)

기타 참여도 과제는 정말 놀이를 했다는것을 사진첨부와 간단한 글을 작성하면 전부다 10점을 주셨던 것 같습니다.

과제는 놀이계획서를 작성하는 것이었는데 배점이 크니 성의있게 최대한 자세히 작성하시길 바랍니다.

같이 강의 들었던 친구는 저와 퀴즈,기말을 같은 점수를 받고도 과제에서 95점을 받아 총점에서 1.5점이 깎여 A0를 받았습니다.


3. 기타사항

퀴즈,기말문제에 대하여 질의응답으로 이의를 제기해도 교수님께서 정답을 번복하는 일은 없으니

교수님의 성격상 그럴일은 없겠지만 괜히 교수님의 기분을 상하게 하여 사적인 감정에 의해 과제 점수를 제대로 받지 못하는 불상사가 없으시길 바랍니다. 

마지막으로, 해당 과목은 교수님의 진심과 성의가 느껴지는, 제가 들었던 사이버강의중 최고의 강의였다고 생각합니다.
Unit 1. 소프트웨어 공학
l	Software Engineering: 실용적으로 실행 가능한 시스템을 만드는 것. 고품질 시스템을 경제적인 방식으로 설계하는데 목적이 있다.
l	소프트웨어의 위기: 적은 비용으로 더 나은 성능으로 발전하는 하드웨어에 비해서 소프트웨어의 발전이 느리다. 
l	원인: 소프트웨어 개발 복잡도 증가, 소프트웨어 개발 비용의 증가
l	소프트웨어 비용: 개발비용 + 개발 이후 비용(ownership cost). 개발 이후 비용인 유지보수 비용이 개발하는 데 드는 비용의 두 배 가량이다. 즉, 유지보수가 가능한 소프트웨어를 만드는 것이 중요하다. 또한 Error는 더 초기의 단계에서 개선될수록 개선 비용이 훨씬 덜 든다.
l	소프트웨어 품질 & 수명: 소프트웨어 엔트로피(잠재되어 있는 error의 정도, 무질서의 정도). 소프트웨어는 유지보수 한 것 때문에 또 다른 문제가 생길 수 도 있다. 개발 직후의 소프트웨어 품질에 따라서 소프트웨어의 수명이 좌우된다.
l	소프트웨어의 위기 극복: 소프트웨어 개발 시 설계적 관점에서 접근해야 한다. 소프트웨어를 재사용해야한다. 좋은 설계 법을 사용한다.



l	다이어그램 오류고치기 + 다이어그램 간단히 그리기 (4개)













Unit2. Process Model
l	<p. 16그림>: Process 품질이 결과적으로는 사용자가 직접 느끼는 품질에까지 영향을 미침
l	Process Quality -> Product Q (Internal Q->External Q) -> Quality in Use
l	Engineering Activities: 요구사항 정의 -> 분석(요구사항 이해+이해한 것을 문서화) -> [범용적 설계 -> 플랫폼 의존적 설계] -> 디자인 -> implement(코딩+UI+DB구축) -> 테스트 -> Deployment -> Operation <-> 유지보수 -> 폐기 
l	개발관련 + 운용 관련

l	Waterfall Model: 옛날 방식으로 시퀀셜한 접근 방식이다. 따라서 고객이 모든 요구사항을 초반에 명확히 하기 어렵고, 중간에 결과물을 볼 수 없다는 점 때문에, 큰 프로젝트에 사용하기 어렵다. 산업계에서 사용 어려움.
l	Spiral Model (<->W): iterative한 특성과 W 모델의 systematic한 부분을 연결 시켰다. 이 모델로 개발된 소프트웨어는 점점 완성도가 높아지게 된다. 따라서 효과적으로 요구사항을 개선하고 수집할 수 있고, 고객의 피드백으로 리스크를 줄일 수 있다. 큰 프로젝트에 대한 현실적인 접근 방식이다. 하지만 진척도를 파악하는데 어려움이 있다.
l	Agile Process (S를 기본 + 구체화): 산업적인 프로세스로 요구사항 변경과 수정에 효과적이다. 고객과 효과적으로 소통함. Iterative & incremental development 기반 self-organizing teams & cross functional team (민주적인 방식으로 팀 전체가 관리의 책임을 짐. 팀 전체가 최선의 방법을 고민하고 결정함.)
l	Scrum! (구체적으로 제품화 한 것)
l	Scrum Roles: Product owner(팀장, 책임자), Scrum Master(Agile방법론 전문가, 코딩X), Development Team(개발자들)로 구성된다.



	
l	1. Grooming: 프로덕트 오너가 PBI로 요구사항을 나눈다. PBI를 PB에 추가 + 수정 +우선순위 화
l	2. Sprint Planning: 개발 팀이 PB에서 몇 개의 Items을 Sprint backlog로 가져오고(각 sprint가 어떤 items을 다룰지 설계함)하나의 feature가 걸리는 시간을 측정하여 어떤 방식으로 처리할 지 세 부화한다. 각 sprint의 첫 과정이다.
l	3. Sprint Execution: 개발 팀이 개발을 수행한다. 결과적으로는 클라이언트에게 보일 수 있을 만한 중간 프로그램(산출물)을 만들어 냄. Self-Organizing함으로써 각 스프린트의 목표를 달성할 수 있는 최선의 방법을 선택한다. Daily Scrum도 진행(팀 멤버가 소통함으로써 팀의 개발 활동이 유연하고 빠르게 진행될 수 있게 한다는 장점이 있다.)
l	4.  Done: (부분적이라도) 실행 가능한 프로그램이 나와야 한다.
l	5-1. Sprint Review: 고객과 Scrum 팀이 만들어진 product를 함께 보면서 review한다. 이후의 개발에도 도움이 됨.
l	5-2. Sprint Retrospective: Scrum 과정에 대해서 review를 한다. Scrum process가 잘 적용됬는지에 관한 것.
l	Product Backlog란? 우선순위화된 프로젝트 작업 리스트. 프로덕트 오너가 리스트를 작성한다. 리스트는 grooming에 따라서 부분적으로 추가, 변경, 삭제될 수도 있다. (ex. 기능적 타입, 결점 타입.)
l	PBI는 규모나 비용을 상대적으로 평가하는 방식을 사용한다.
l	각 스프린트는 time-boxed하다. 즉, 각각 반복의 기간은 동일하다.



Unit 3. Requirement Engineering

l	부실 -> 상세한 요구사항으로 보완!
l	1. Inception: 고객 확인/다양한 관점 인식/소통을 시작. <p. 74> 참고
l	2. Eliciting Requirements: 문제를 명확히 하는 데에 목적이 있다. 협동적 요구사항 수집 + 품질 function deployment(기술 요구서로 상세화)
l	3. Elaboration: 어떤 analysis 모델이 필요한 지 수립(DFD……)
l	4. Negotiation:  주어진 조건으로 개발할 수 있는 지 고객과 협의. Win-win하는 방식으로
l	5. Specification: 서로가 동의하는 요구사항을 문서로 정의한다. 표준 양식에 맞추어 기술한다.
l	6. Validation: 요구사항 명세서가 에러가 없는지, 적당한 수준으로 구체화 됬는지? 유효성을 검증한다.
l	7. Requirements Management: 요구사항의 변경에 대해 기록, 관리. 요구사항을 변경하게 될 수도 있기 때문에





Unit 4. Structured Analysis
l	Data Flow Diagram: 데이터의 흐름과 변동에 대한 정보들을 묘사한 다이어그램
l	Terminal: 생산자/고객/디바이스/센서
l	Process: 함수와 같음/동사 형태 ex)compute taxes, determine area, format report, display graph
l	Data Flow: 명사 형태/ 전달되는 데이터의 정보를 명시
l	Data Store: 버퍼/DB
l	DFD Leveling: 레벨 0은 가장 기초적인 시스템 모델. 모든 레벨은 인풋, 아웃풋이 그대로 유지되어야 함.









Unit 5. Object-Oriented Analysis and Design(OOAD)
1.	Defining Requirement: 요구사항 정의 (기능적 + 비기능적 요구사항 모두) 
2.	Functional Modeling: 타겟 시스템의 기능성을 분석. Use Case 다이어그램
3.	Object Modeling: 객체 단위의 데이터와 그 관계들을 분석. Class 다이어그램
l	클래스 다이어그램은 제안 된 시스템의 정적 구조와 그 동작들을 나타내는 반면 ER 다이어그램은 데이터 모델의 추상적인 표현만 나타낸다는 차이점이 있다.
4.	Dynamic Modeling: 타겟 시스템이 실행되는 순서를 분석. 시퀀스 다이어그램 for Use Case
5.	Architecture Design: 시스템 전체 구조를 설계
6.	User Interface Design: UI 설계
7.	Detailed OO Design: 분석과 초기 버전 설계, 실제 코드와 유사
8.	DB Design
9.	Implementation: 실제 구현
10.	Testing & Deployment: 테스팅 
l	Object Management Group -> UML (통합 모델링 언어)
l	Use Case 다이어그램: 유즈케이스와 액터들 간 관계를 포함하여 시스템들의 기능적 요구 사항들을 시각화 시킴으로써 개발자와 클라이언트가 함께 이해하기 쉬운 다이어그램이다.
n	Actor: 목표시스템을 사용하는 특정한 역할
n	Use Case: 기능 단위/동사 형태/CRUD-based 기능을 고려하여 유즈케이스를 찾는다.
n	유즈케이스에서의 Relationship들
n	1. Generalization: 상속. 의존성, 공통 기능성은 구현하지 않는다.
n	2. Include: 포함되는 유즈케이스는 항상 호출 되어 훨씬 compact해진다.
n	3. Extend: 예외 사항. 특정 조건을 만족할 때 실행됨.
l	클래스 다이어그램: 클래스 기반 설계. SRS에서 명사구 추출 -> 적합하지 않은 클래스 제외 -> 좋은 클래스만 남김
l	SRS Problem
- 누락된 정보
- 일관성 결여
- 부 정확성
- 모호성
- 중복성
l	클래스 간의 Relationship들: 
l	1. Dependency: A가 B에게 메시지를 보내는 관계로서 임시적인 link임. 기록X
l	2. Association: 영구적인 link임. 기록 O. 클래스 사이의 관계이다. (ex. 고객-계좌 /승객-항공권/학생-cID)
l	=> link는 인스턴스 간의 관계. 영구적 기록 O ->association / X -> Dependency
l	=> Cardinality: 복수성. 반대쪽의 클래스가 몇 개의 클래스와 Association될 수 있는지 표시
l	3. Aggregation: 약한 포함관계이다. 전체가 사라져도 전체를 구성하는 부분은 남겨진다. 생성 자에서 파라미터로 가져온다.
l	4. Composition: 강한 포함관계이다. 전체를 삭제하면 부분도 함께 삭제된다. 생성 자에서 파라미터로 가져옴.
l	5. Inheritance: 모든 클래스와 속성을 내가 가진 것처럼 상속받아 사용하는 것 
l	Sequence 다이어그램: 시퀀스에서 다른 객체들 간의 호출 관계와 다른 객체들로의 호출까지 상세하게 보여주는 다이어그램. 즉 각 유즈케이스 간의 내부의 메시지 호출 순서를 보여주는 것. 유즈케이스 description을 매세지 패싱을 통해 다이어그램으로 옮긴 것. 또한 메시지를 받는 객체는 그 객체 안에 동일한 이름의 메소드와 속성들이 존재해야 한다.
n	Controller Object: 전체적인 흐름을 관리하는 역할을 하며, 중간에서 메시지를 주고받도록 처리한다.
n	Participating Object: 수동적 객체로 호출이 되면 실행된다.
n	Traceability: 추적성. 이전 단계의 산출물을 보고 현재의 결과물이 왜 나왔는지 추적하기 쉽다면 추적성이 좋은 것이고 좋은 개발이라고 할 수 있다.
n	Synchronous Call (     ) : 가장 많이 사용되는 콜. 메시지가 답이 올 때 까지 기다림
n	Asynchronous Call (     ): 기다림 없이 메시지를 바로 리턴 하고 다음 메소드를 실행 -> 전체적인 성능 향상
n	Interaction Operator ->
u	Alt: if-then-else문/switch문과 동일. 여러 개중 하나 선택
u	Opt: if-then 조건이 맞으면 실행.
u	Loop: 반복문. Loop(1,max)
u	Break: 중지. 조건 []로 명시
u	Par: 병렬처리 지원
u	속성 값이나 객체 자체에 대해서 제약 사항을 명시할 수 도 있다.


Unit 6. ISO 9126 Quality Model
l	Quality Model: 소프트웨어 품질 측정법
l	Process Quality -> Product Q (Internal Q->External Q) -> Quality in Use
l	어떤 방법론을 선택하는지에 따라서 중간산출물의 품질과, 코드의 품질이 달라지고 최종적으로는 유저가 느끼는 품질의 정도도 달라지게 된다.
l	Six Characteristics: 어떻게 측정할까? 이 6개의 품질 특성으로 측정함. 개발하려는 소프트웨어마다 가중치가 다를 수 있다(0.. 1 까지 품질의 값을 표시)
l	1. Functionality: 원하는 요구에 맞춰 function을 제공하는 소프트웨어의 능력
l	2. Reliability: 소프트웨어의 성능을 일정한 수준으로 유지시키는 능력
l	3. Usability: 사용성 
l	4. Efficiency: 사용되는 자원의 양을 고려할 때 적정 수준의 성능을 제공하는 소프트웨어의 능력
l	5. Maintainability: 유지보수성
l	6. Portability: 이 식성
l	Sub-characteristics of Reliability(신뢰도)
ð	Maturity (성숙도): 예외처리를 잘 해서 fault 때문에 failure(정지)되는 것을 방지하는 소프트웨어의 능력
ð	Fault Tolerance:  오류가 난 상황에서도 적정한 수준의 성능을 유지시키는 소프트웨어의 능력
ð	Recoverability(복구 능력): 오류때문에 정지가 되도 신속하게 re-establish하면서 데이터를 자동으로 안전하게 회복시키는 소프트웨어의 능력
ð	Reliability Compliance: 신뢰성과 관련한 규제나 표준을 얼마나 충족했는지 하는 정도
l	Sub-characteristics of Efficiency(효율성)
ð	Time-Behavior: 기능을 수행시킬 때 시간 측면에서 빠르게 반응을보이는 소프트웨어의 능력
ð	Resource Utilization: 적당한 양의 자원으로 소프트웨어를 사용할 수 있는 능력
ð	Efficiency Compliance: 표준을 준수하는 능력
l	Quality in Use: 사용 중 사용자가 직접 느끼는 품질 -> 효과 성, 생산성, 안정성, 만족도


